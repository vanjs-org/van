{let e,t,{fromEntries:r,entries:o,keys:l,getPrototypeOf:n}=Object,{get:f,set:i,deleteProperty:a,ownKeys:s}=Reflect,c=Symbol,{state:d,derive:y,add:u,tags:m}=van,w=n(d()),g=1e3,p=c(),v=c(),P=c(),b=c(),D=c(),O=c(),_=e=>(e[P]=1,e),j=e=>e?.[P]?y(()=>A(e())):d(A(e)),A=e=>{if(!(e instanceof Object)||e[p])return e;let t=new Proxy((e[p]=r(o(e).map(([e,t])=>[e,j(t)])),e[v]=e,e[b]=[],e[D]=d(1),e),{get:(e,r)=>n(e[p][r]??0)===w?e[p][r].val:("length"===r&&e[D].val,f(e,r,t)),set(e,r,o){let l=e[p];if(r in l)return l[r].val=A(o),1;let n=r in e;return i(e,r,o)?(n||i(l,r,j(o))&&(++e[D].val,x(t,r,l[r])),1):void 0},deleteProperty:(e,t)=>(a(e[p],t)&&E(e,t),a(e,t)&&++e[D].val),ownKeys:e=>(e[D].val,s(e))});return t},K=e=>e[p],S=e=>e[b]=e[b].filter(e=>e.t.isConnected),h=(e,t,r,o)=>()=>{let l=o(r,()=>delete e[t],t);return l[O]=t,l},k=(e,t,r,{t:o,f:n},f)=>{if(u(o,h(e,t,r,n)),!f&&Array.isArray(e)&&t!=e.length-1){let t={};for(let e of o.childNodes)t[e[O]]=e;let r=o.firstChild;for(let n of l(e))r===t[n]?r=r.nextSibling:o.insertBefore(t[n],r)}},x=(e,r,o)=>S(e).forEach(k.bind(t,e,r,o)),E=(e,t)=>{for(let r of S(e))[...r.t.childNodes].find(e=>e[O]===t)?.remove()},F=r=>(e??(setTimeout(()=>(e.forEach(S),e=t),g),e=new Set)).add(r),R=(e,t,r)=>{let l={t:e(),f:r};t[b].push(l),F(t);for(let[e,r]of o(t[p]))k(t,e,r,l,1);return l.t},T=(e,t)=>{let l=Array.isArray(e)?o(t(e.filter(e=>1))):t(o(e)),n=e[v],f=r(l),i=e[p],a=r(l.map(([e,t])=>{let r=i[e];return r?r.val=A(t):r=j(t),[e,r]}));for(let{t:t,f:r}of S(e)){let l={};for(let e of[...t.childNodes])e[O]in a?l[e[O]]=e:e.remove();let n=t.firstChild;for(let[f,i]of o(a))n===l[f]?n=n.nextSibling:t.insertBefore(l[f]??m.div(h(e,f,i,r)).firstChild,n)}for(let e in n)delete n[e];for(let e in f)n[e]=f[e];e[p]=a,++e[D].val};window.vanX={calc:_,reactive:A,stateFields:K,list:R,replace:T}}